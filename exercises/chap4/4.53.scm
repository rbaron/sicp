; Load this file and drop yourself in the REPL with:
; $ cat 4.53.scm - | mit-scheme

(load "book-code/ch4-mceval.scm")
(load "book-code/ch4-ambeval.scm")

; BEGIN CODE COPY

; From exercise 4.51
(define (analyze-permanent-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (set-variable-value! var val env)
               (succeed
                 'ok
                  fail2))
             fail))))

(define (permanent-assignment? exp)
  (tagged-list? exp 'permanent-set!))

; From exercise 4.52
(define (analyze-if-fail exp)
  (let ((proc (analyze (cadr exp)))
        (alternative (analyze (caddr exp))))
    (lambda (env success fail)
      ; Call proc. The failure of if willbe the call to alternative
      (proc
        env
        (lambda (val fail2)
          (success val fail2))
        (lambda ()
          (alternative
            env
            (lambda (val fail3)
              (success val fail3))
            fail))))))

(define (if-fail? exp)
  (tagged-list? exp 'if-fail))

; Installing the procedures
(define (analyze exp)
  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((permanent-assignment? exp) (analyze-permanent-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((if-fail? exp) (analyze-if-fail exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((let? exp) (analyze (let->combination exp))) ;**
        ((amb? exp) (analyze-amb exp))                ;**
        ((application? exp) (analyze-application exp))
        (else
         (error "Unknown expression type -- ANALYZE" exp))))


(define the-global-environment (setup-environment))
(driver-loop)

(define (require p)
  (if (not p) (amb)))

(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))

(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))

; END CODE COPY

; Defining the prime? procedure (very naÃ¯ve)
(define (prime? n)
  (define (internal n test)
    (cond ((= n 1) false)
          ((= n test) true)
          ((= (remainder n test) 0) false)
          (else (internal n (+ test 1)))))
  (internal n 2))

(prime? 1)  ;#f
(prime? 2)  ;#t
(prime? 5)  ;#t
(prime? 11) ;#t
(prime? 18) ;#f

; Testing
(let ((pairs '()))
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
             (permanent-set! pairs (cons p pairs))
             (amb))
           pairs))

; The (amb) call inside let will cause the problem to backtrack
; as soon as a valid pair is generated by prime-sum-pair. This code
; will run all at once and return. When it exits, pairs will be
; the list of the pairs whose sum is prime. It will be returned as the
; alternative to if-fail

; Output:
; => ((8 35) (3 110) (3 20))
