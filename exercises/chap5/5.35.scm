; What expression was used to generate the following procedure?


  ; Compilation of a lambda
  (assign val (op make-compiled-procedure) (label entry16) (reg env))
  (goto (label after-lambda15))

  ; Entrypoint from lambda. Generated by compile-lambda-body
entry16
  ; Here the procedure is being called. proc holds the procedure
  ; representation, which is a list with the entry point and the environment
  (assign env (op compiled-procedure-env) (reg proc))

  ; Here it shows that x is the argument to the procedure
  (assign env (op extend-environment) (const (x)) (reg argl) (reg env))

  ; Start from compile-sequence from lambda's body
  ; First expression in the body is a procedure application.
  ; The precedure itself is a symbol + which is simply looked up.
  (assign proc (op lookup-variable-value) (const +) (reg env))

  ; We now start the compilation of the operands
  (save continue)
  (save proc)
  (save env)

  ; The first (actually, last) operang is an application (g ...)
  ; We proceed by compiling this call:
  (assign proc (op lookup-variable-value) (const g) (reg env))

  ; Compilation of g's argument (+ ...)
  (save proc)
  (assign proc (op lookup-variable-value) (const +) (reg env))

  ; Construction of operands for (+ ...)
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))

  ; argl was populated with (x 2) (actually, the looked up value of x :P)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
compiled-branch18
  (assign continue (label after-call17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch19
  ; We then evaluate (+ x 2) and store the result in val
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

; Continue the evaluation of g
after-call17

  ; We now have the argument (+ x 2) evaluated into val.
  ; Store the argument list for g in argl
  (assign argl (op list) (reg val))

  ; proc holds g again
  (restore proc)

  ; start procedure call
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))

; Evaluation of compiled procedure g. We setup continue and jump to g's
; entrypoint.
compiled-branch21
  (assign continue (label after-call20))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))

primitive-branch22
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

; g's return with result in val
after-call20

  ; start the construction of argl for the original +
  ; argl contains the result of (g (+ x 2))
  (assign argl (op list) (reg val))
  (restore env)

  ; lookup x and cons it to argl
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))

  ; proc holds initial +
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch25))
compiled-branch24
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch25

  ; Application of the original +
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call23
after-lambda15

  ; A lambda was compiled and the resulting code was assigned to val.
  ; Here a new variable f is defined to point to that code.
  (perform (op define-variable!) (const f) (reg val) (reg env))
  (assign val (const ok))

; Using the commented code, we can now see that the compiled code came
; from the compilation of the expression:

(define (f x)
  (+ x (g (+ x 2))))
